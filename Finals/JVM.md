# JVM

JVM 中核心且基础的 2 块内容：内存模型 和 类加载机制，下面会对这 2 块内容做一个总结。JVM 中其他重要的技术点如：字节码技术、JVM 启动参数、JVM 调优

## 1. JVM 内存模型

​		Java 虚拟机将运行时内存区域划分为五个部分：**方法区**、**堆**、**PC 寄存器**、**Java 方法栈**和**本地方法栈**。

* ### 1.1 JVM 内存模型图

  ![](https://github.com/PayneWoo/JAVA-000/blob/master/Week_01/JVM.png?raw=true)

## 2. JVM 类加载

虚拟机提供了可移植性， Java 代码被 Javac 编译器编译成字节码之后，就可以在不同平台上的 Java 虚拟机运行。一次编写，处处运行。

### 2.1 JVM 中字节码的执行

* **从 JVM 的角度来看：**

  Javac 编译器将 Java 源码编译成字节码文件；然后 JVM 通过 **类加载机制**  将字节码文件加载到 JVM 内存当中（方法区）；实际运行时，JVM 会执行方法区内的代码，每当调用进入一个 Java 方法，JVM 会在当前线程的 Java 方法栈中生成一个栈帧，用于存放局部变量以及字节码的操作数。当退出当前执行的方法时（无论是正常返回还是异常返回），JVM 都会弹出当前线程的当前栈帧，并将其舍弃。

* 从 **硬件的角度来看：**

  Java 字节码无法直接执行。因此，JVM 需要将字节码翻译成机器码。HotSpot JVM 有 2 种翻译形式：**解释执行** 和 **即时编译**。

  * 解释执行：逐条将字节码翻译成机器码并执行
  * 即时编译：即将一个方法中包含的所有字节码编译成机器码后再执行

  <img src="https://i.loli.net/2021/02/06/B4NHQOWvXKCRThf.png" alt="image-20210206222710024" style="zoom:50%;" />

### 2.2 JVM 的类加载过程



<img src="https://i.loli.net/2021/02/07/4dM1BL6KEsCAlbq.png" alt="image-20210206232300858" style="zoom:40%;" />

 * 加载（查找字节流，并据此创建类的过程）
 * 链接（将创建成的类合并至 JVM 中，使之能够执行的过程）
   * 验证
   * 准备
   * 解析
 * 初始化（给被标记为常量值的字段赋值，以及执行 <clinit>方法的过程）
 * 使用
 * 卸载

### 2.3 类加载

#### 2.3.1 类加载器

* 启动类加载器（用来加载 Java 的核心库）
* 扩展类加载器（用来加载 Java 的扩展库）
* 应用类加载器（根据 Java 应用的类路径（CLASSPATH）来加载 java 类）

####  2.3.2 类加载过程

* 双亲委托机制



<img src="https://i.loli.net/2021/02/06/T7pz5UQeGhDOtnv.png" alt="image-20210206230241702" style="zoom:50%;" />



#### 2.3.3 类加载器的 3 个作用

* （1）将 Class 加载到 JVM 中
* （2）审查每个类应该由谁加载，它是一种 父优先的等级加载机制
* （3）将 Class 字节码重新解析成 JVM 统一要求的对象格式

#### 2.3.4 JVM加载 class 文件到内存的 2 种方式：

* **隐式加载：** 就是不通过在代码里调用 ClassLoader 类来加载需要的类，而是通过 JVM 来自动加载需要的类到内存的方式。
* **显式加载：** 就是在代码中通过调用 ClassLoader 类来加载一个类。（eg：调用 Class.forName() 或者 this.getClass.getClassLoader().loadClass() ）



